## 说说前后端分离的好处

- 1、最大的好处就是前端JS可以做很大部分的数据处理工作，对服务器的压力减小到最小。
- 2、后台错误不会直接反映到前台，错误提示比较友好。
- 3、由于后台是很难去探知前台页面的分布情况，而这又是JS的强项，而JS又是无法独立和服务器进行通讯的。
所以单单用后台去控制整体页面，又或者只靠JS完成效果，都会难度加大，前后台各尽其职可以最大程度的减少开发难度。
- 4、有利于人员专业化，提高效率和质量。
- 5、测试数据，可以直接拿来演示，提高开发效率。


- - -
## MVVM框架的双向数据绑定是怎么实现的？


- - -
## React中哪些地方发生变化，React能够检测到？
props 和 state 的改变组件能够监听到，但是用var 或者let 定义的全局变量发生变化组件是监听不到的。

- - -
## 渲染量
> 页面上有100个节点，目前需要从新渲染其中3个，我们本来是想值渲染三个，但是根据 React 的更新规则，
> 只要组件的 props 或 state 发生了变化就会重新渲染整个组件，因此除了想要渲染的3个节点以外，还需要重新渲染所有的剩余的97个节点。

- - -
## `Pure Component`

如果一个组件只和 props 和 state 有关系，给定相同的 props 和 state 就会渲染出相同的结果，那么这个组件就叫做纯组件，
换一句话说纯组件只依赖于组件的 props 和 state，下面的代码表示的就是一个纯组件。

    render() {
         return (
             <div style={{width: this.props.width}}>
                      {this.state.rows}
             </div>
         );
    }

- - -
## git如何强拉覆盖本地文件
    git fetch --all
    git reset --hard origin/master
    git pull

- - -
## 一个项目在构建过程中都做了什么事？


- - -
## 两个数组求并集，交集，差集

    a = [1, 2, 3]
    b = [2, 4, 5]

### ES7
ES7新增了一个Array.prototype.includes的数组方法，用于返回一个数组是否包含指定元素，结合filter方法。

> var boolean = array.includes(searchElement[, fromIndex])

    // 并集
    let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5]
    
    // 交集
    let intersection = a.filter(v => b.includes(v)) // [2]
    
    // 差集
    let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,3,4,5]

### ES6
ES6中新增的一个Array.from方法，用于将类数组对象和可遍历对象转化为数组。只要类数组有length长度，基本都可以转化为数组。结合Set结构实现数学集求解。

> Array.from(arrayLike[, mapFn[, thisArg]])

    let aSet = new Set(a)
    let bSet = new Set(b)
    
    // 并集
    let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5]
    
    // 交集
    let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))) // [2]
    
    // 差集
    let difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v)))) // [1,3,4,5]

### ES5
可以用indexof 和 filter结合起来使用。但是如果一个是无限大数组，一个是空数组。这样会很浪费时间，怎么优化？

- - -
## 如何判断两个数组全等？
> 数组内有`NaN`, `obj`,`boolean`  等各种类型

- - -
## 高效的数组去重




